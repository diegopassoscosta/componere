{"name":"Componere","tagline":"webframework em javascript para construção de webcomponents","body":"# Components Framework\r\nÉ um webframework para construção de webcomponents.\r\n\r\n## Instalação\r\nPara instalar, basta incluir o arquivo components.min.js na pagina html.\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <title></title>\r\n    <script type=\"text/javascript\" src=\"https://raw.githubusercontent.com/web-components/componere/master/componere.min.js\"></script>\r\n</head>\r\n<body>\r\n</body>\r\n</html>\r\n```\r\n\r\n## Utilização básica\r\nOs componentes são declarados no arquivo html sempre com os atributos type e id. O type dos componentes já são as URIs que irão fornecer o código do componente, portanto, o próprio framework resolve o type, instala o componente e inicia.\r\n\r\n```html\r\n<component type=\"./timer.js\" id=\"myTimer\"></component>\r\n```\r\n\r\n### Meu primeiro componente\r\nPara construir um componente, basta acessar o contrutor que o framework disponibiliza no escopo global da aplicação javascript. O construtor sempre deve receber o id do componente que conforme explicado na utilização básica deve sempre ser a URI do componente.\r\n\r\n```js\r\nvar MyFirstComponent;\r\nMyFirstComponent = new Component('./my-first-component.js');\r\n```\r\n\r\nE para acessar o componente, basta inclui-lo na sua página html.\r\n\r\n```html\r\n<component type=\"./my-first-component.js\" id=\"myFirstComponentInstance\"></component>\r\n```\r\n\r\n### Adicionando comportamento\r\nO componente anterior não faz muita coisa além de existir no browser. Para adicionarmos um pouco de comportamento devemos olhar o ciclo de install. No ciclo de install o componente ainda não recebeu nenhuma das interfaces requeridas e nenhum evento esta sendo escutado ou emitido pelo componente. Portanto, é nessa etapa que devemos adicionar métodos ao nosso componente. Após tudo ter sido realizado, a callback done deve ser invocado para informar ao framework que o ciclo de instalação terminou.\r\n\r\n```js\r\nvar MyFirstComponent;\r\nMyFirstComponent = new Component('./my-first-component.js');\r\nMyFirstComponent.install(function (done) {\r\n    this.sayHello = function () {\r\n        alert('Hello!');\r\n    };\r\n    done();\r\n});\r\n```\r\n\r\nAgora precisamos apresentar a mensagem para o usuário, para fazer isso, devemos olhar o ciclo de start. No ciclo de start o componente já esta pronto para ser usado, todas as interfaces foram fornecidas todos os eventos já estão sendo escutados e todos os métodos ja foram adicionados. Portanto, é nessa etapa que devemos iniciar o comportamento do componente. Analogo ao ciclo de install, o callback done deve ser invocado após tudo ter sido executado.\r\n\r\n```js\r\nvar MyFirstComponent;\r\nMyFirstComponent = new Component('./my-first-component.js');\r\nMyFirstComponent.install(function (done) {\r\n    this.sayHello = function () {\r\n        alert('Hello!');\r\n    };\r\n    done();\r\n});\r\nMyFirstComponent.start(function (done) {\r\n    this.sayHello();\r\n    done();\r\n});\r\n```\r\n\r\n### Manipulando graficamente\r\nTodo componente possui uma referência para o elemento do DOM que o invocou, esse elemento é o escopo de aplicação do componente e pode ser acessada pela propriedade element.\r\n\r\n```js\r\nvar MyFirstComponent;\r\nMyFirstComponent = new Component('./my-first-component.js');\r\nMyFirstComponent.install(function (done) {\r\n    this.html = function (val) {\r\n        if (val) { this.element.innerHTML = val; }\r\n        return this.element.innerHTML;\r\n    };\r\n    done();\r\n});\r\nMyFirstComponent.start(function (done) {\r\n    this.html('ola!');\r\n    done();\r\n});\r\n```\r\n\r\nVale notar que o objeto element é um objeto do DOM e portanto implementa toda a API de HTMLElementPrototype com métodos como appendChild, innerHTML, etc...\r\n\r\n### Herança de componentes\r\nTodo componente pode ser extendido, e um componente pode extender múltiplos componentes distintos, para extender um componente, devemos utilizar o método extend passando a URI do componente que desejamos extender.\r\n\r\nPor exemplo, vamos supor que desejamos extender o MyFirstComponent criando um novo componente MyAwsomeComponent.\r\n\r\n```js\r\nvar MyAwsomeComponent;\r\nMyAwsomeComponent = new Component('./my-awsome-component.js');\r\nMyAwsomeComponent.extend('./my-first-component.js');\r\nMyAwsomeComponent.install(function (done) {\r\n    this.fizz = function () {\r\n        this.html('fizz');\r\n    };\r\n    \r\n    this.buz = function () {\r\n        this.html('buz');\r\n    };\r\n    done();\r\n});\r\nMyAwsomeComponent.start(function (done) {\r\n    this.fizz();\r\n    done();\r\n});\r\n```\r\nNote que como MyAwsomeComponent extende MyFirstComponent o método html esta acessível.\r\n\r\n### Emitindo e escutando eventos de outros componentes\r\nTodo componente pode emitir e escutar eventos de outros componentes. Por exemplo, vamos supor que desejamos ter um componente timer que fica a cada segundo emitindo um sinal de tick e um couter que toda vez que recebe um sinal de tick incrementa um contador.\r\n\r\n```js\r\nvar Timer;\r\nTimer = new Component('./timer.js');\r\nTimer.publish('tickEvent');\r\nTimer.install(function (done) {\r\n    this.tick = function () {\r\n        this.tickEvent();\r\n        element.innerHTML = element.innerHTML === '-' ? '|' : '-';\r\n        this.tickEvent();\r\n    };\r\n    done();\r\n});\r\nTimer.start(function (done) {\r\n    setInterval(this.tick.bind(this), 1000);\r\n    done();\r\n});\r\n```\r\n\r\nNote que ao informar que o timer emite um evento tickEvent automaticamente, um método tickEvent é adicionado ao componente que quando chamado dispara o evento. Lembre-se no ciclo de install esse método ainda não foi adicionado ao componente e portanto o evento não pode ser emitido, apenas após o ciclo de install isso pode ocorrer, por isso, apenas no start o tick é chamado.\r\n\r\n```js\r\nvar Counter;\r\nCounter = new Component('./counter.js');\r\nCounter.listen('tickEvent', function () {\r\n    this.add();\r\n});\r\nCounter.install(function (done) {\r\n    var counted = 0;\r\n\r\n    this.add = function () {\r\n        counted += 1;\r\n        element.innerHTML = counted.toString();\r\n    };\r\n\r\n    done();\r\n});\r\n\r\n```\r\n\r\nNote que para informar que o componente escuta um evento tickEvent, devemos utilizar o método listen. No callback do evento, o componente ja passou pelos ciclos de install e start e, portanto, o componente já está montado e pronto para uso.\r\n\r\nApós criados os componentes, devemos instancia-los e ligar as instancias para escutarem os eventos das instâncias corretas.\r\n\r\n```html\r\n<component type=\"./timer.js\" id=\"timerInstance\"></component>\r\n<component type=\"./counter.js\" id=\"counterInstance\" tickEvent=\"timerInstance\"></component>\r\n``` \r\n\r\n### Requisitando e provendo interfaces\r\nTodo componente pode prover e requisitar interfaces. Por exemplo, vamos supor que desejamos ter um componente car que desenha na tela um carro, contudo, para desenhar o carro, devemos saber a sua posição e para saber a posição do carro, precisamos saber o tempo transcorrido. Portanto, o componente car vai requerer uma interface watchInterface que retorna o tempo e vamos implementar um componente watch que irá prover essa interface.\r\n\r\n```js\r\nvar Watch;\r\nWatch = new Component('./watch.js');\r\nWatch.install(function (done) {\r\n    this.hours = function () {\r\n        return new Date().getHours();\r\n    };\r\n    \r\n    this.minutes = function () {\r\n        return new Date().getMinutes();\r\n    };\r\n    \r\n    this.seconds = function () {\r\n        return new Date().getSeconds();\r\n    };\r\n    \r\n    done();\r\n});\r\nWatch.provide('watchInterface', function (done) {\r\n    done({\r\n        'hours'   : this.hours,\r\n        'minutes' : this.minutes,\r\n        'seconds' : this.seconds\r\n    });\r\n});\r\n```\r\nNote que o provide recebe uma função que constrói a interface provida, essa função, é executada no contexto do componente e só é executada após o ciclo de install. O componente montado deve ser devolvido pelo callback done.\r\n\r\n```js\r\nvar Car;\r\nCar = new Component('./car.js');\r\nCar.require('watchInterface', function (watch, done) {\r\n    this.watch = watch;\r\n    done();\r\n});\r\n```\r\nNote que o require recebe a interface requerida no callback passado. O contexto de execução do callback é o do componente, portanto, podemos adicionar ao objeto a interface requerida como um atributo para uso posterior.\r\n\r\nApós criados os componentes, devemos instancia-los e ligar as instancias para proverem as interfaces.\r\n\r\n```html\r\n<component type=\"./watch.js\" id=\"watchInstance\"></component>\r\n<component type=\"./car.js\" id=\"carInstance\" watchInterface=\"watchInstance\"></component>\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}